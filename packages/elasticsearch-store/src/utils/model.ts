import { FieldType, DataTypeFields } from '@terascope/types';
import { DataType, LATEST_VERSION } from '@terascope/data-types';
import {
    cloneDeep, isPlainObject, concat,
    getWordParts, firstToUpper, isNumberLike,
    isKey
} from '@terascope/utils';

/** JSON Schema */
export const schema = {
    additionalProperties: false,
    properties: {
        _key: {
            type: 'string',
        },
        client_id: {
            type: 'number',
            multipleOf: 1.0,
            minimum: 0,
            default: 1,
        },
        _deleted: {
            type: 'boolean',
            default: false
        },
        _created: {
            format: 'date-time',
        },
        _updated: {
            format: 'date-time',
        },
    },
    required: ['_key', 'client_id'],
};

export function makeRecordDataType(arg: {
    name: string;
    description?: string;
    fields: DataTypeFields;
}): DataType {
    return new DataType({
        fields: {
            ...arg.fields,
            _created: { type: FieldType.Date, description: 'Record creation time' },
            _updated: { type: FieldType.Date, description: 'Last record modified time' },
            _deleted: { type: FieldType.Boolean, description: 'A flag to indicate whether the record is deleted' },
            _key: { type: FieldType.Keyword, description: 'The unique ID for the record (autogenerated on creation)' },
            client_id: { type: FieldType.Integer, description: 'The client id namespace, 0 is global' },
        },
        version: LATEST_VERSION
    }, arg.name, arg.description);
}

export function addDefaultSchema(input: Record<string, any>): Record<string, any> {
    return mergeDefaults(input, schema);
}

/**
 * Deep copy two levels deep (useful for mapping and schema)
 */
export function mergeDefaults<T extends object>(source: T, from: Partial<T>): T {
    const output = cloneDeep(source);
    const _mapping = from ? cloneDeep(from) : {};

    for (const [key, val] of Object.entries(_mapping)) {
        if (isKey(output, key) && output[key] != null) {
            if (isPlainObject(val)) {
                output[key] = Object.assign(output[key], val);
            } else if (Array.isArray(val)) {
                output[key] = concat(output[key], val) as T[string & keyof T];
            } else {
                output[key] = val as T[string & keyof T];
            }
        }
    }

    return output;
}

export function toInstanceName(name: string): string {
    return getWordParts(name).map(firstToUpper)
        .join('');
}

const _wildcardRegex = /[^A-Za-z0-9]/gm;
export function uniqueFieldQuery(field: string): string {
    const parsed = field
        .replace(_wildcardRegex, '.')
        .split('')
        .map((char) => {
            if (char !== '.' && !isNumberLike(char)) {
                return `[${char.toLowerCase()}${char.toUpperCase()}]`;
            }
            return char;
        })
        .join('');
    return `/${parsed}/`;
}

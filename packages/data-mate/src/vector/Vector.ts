import {
    DataTypeFieldConfig,
    Maybe, SortOrder,
    ReadonlyDataTypeFields
} from '@terascope/types';
import {
    ReadableData, createHashCode, HASH_CODE_SYMBOL, getHashCodeFrom
} from '../core';
import { VectorType } from './interfaces';

/**
 * An immutable typed Array class with a constrained API.
*/
export abstract class Vector<T = unknown> {
    /**
     * Make an instance of a Vector from a config
    */
    static make<R>(
        data: ReadableData<R>,
        options: VectorOptions
    ): Vector<R> {
        throw new Error(`This is overridden in the index file, ${options} ${data}`);
    }

    /**
     * The name of field, if specified this will just be used for metadata
    */
    readonly name?: string;

    /**
     * The type of Vector, this should only be set the specific Vector type classes.
    */
    readonly type: VectorType;

    /**
     * The field type configuration
    */
    readonly config: Readonly<DataTypeFieldConfig>;

    /**
     * When Vector is an object type, this will be the data type fields
     * for the object
    */
    readonly childConfig?: ReadonlyDataTypeFields;

    /**
     * A data type agnostic in-memory representation of the data
     * for a Vector and potential indices/unique values.
     *
     * This should be generated by the builder and
     * should NOT be mutated one created.
     *
     * @internal
    */
    readonly data: ReadableData<T>;

    /**
     * If set to false, the Vector is not sortable
    */
    sortable = true;

    #cachedHash?: string|undefined;

    constructor(
        /**
         * This will be set automatically by specific Vector classes
         */
        type: VectorType,
        data: ReadableData<T>,
        options: VectorOptions
    ) {
        this.type = type;
        this.data = data;
        this.name = options.name;
        this.config = options.config;
        this.childConfig = options.childConfig;
    }

    /**
     * A function for converting an in-memory representation of
     * a value to an JSON spec compatible format.
    */
    abstract valueToJSON?(value: T): any;

    * [Symbol.iterator](): IterableIterator<Maybe<T>> {
        yield* this.data;
    }

    get [HASH_CODE_SYMBOL](): string {
        if (this.#cachedHash) return this.#cachedHash;

        const hash = createHashCode(this.toJSON());
        this.#cachedHash = hash;
        return hash;
    }

    /**
     * Returns the number items in the Vector
    */
    get size(): number {
        return this.data.size;
    }

    /**
     * Get the count of distinct values.
     *
     * @note this is O(1) for non-object types and O(n) + extra hashing logic for larger objects
    */
    countUnique(): number {
        return this.unique().length;
    }

    /**
     * Get the unique values
    */
    unique(): readonly T[] {
        const results: T[] = [];
        const hashes = new Set<any>();
        const getHash = this.data.isPrimitive ? (v: any) => v : getHashCodeFrom;
        for (const value of this.data.values.values()) {
            const hash = getHash(value);
            if (!hashes.has(hash)) {
                hashes.add(hash);
                results.push(value);
            }
        }
        return results;
    }

    /**
     * Get value by index
    */
    get(index: number, json?: boolean): Maybe<T>|Maybe<JSONValue<T>> {
        const val = this.data.get(index);

        if (!json || !this.valueToJSON) {
            return val;
        }

        if (val == null) return val;
        return this.valueToJSON(val as T);
    }

    /**
     * Create a new Vector with the same metadata but with different data
    */
    fork(data: ReadableData<T>): this {
        // @ts-expect-error
        return new this.constructor(data, {
            childConfig: this.childConfig,
            config: this.config,
            name: this.name,
        });
    }

    /**
     * Create a new Vector with the range of values
    */
    slice(start?: number, end?: number): Vector<T> {
        return this.fork(
            new ReadableData(this.data.slice(start, end))
        );
    }

    /**
     * Sort the values in a Vector and return
     * an array with the updated indices.
    */
    getSortedIndices(direction?: SortOrder): number[] {
        if (!this.sortable) {
            throw new Error(`Sorting is not supported for ${this.constructor.name}`);
        }

        const len = this.size;
        const indices: number[] = Array(len);
        const original: [number, Maybe<T>][] = Array(len);

        for (let i = 0; i < len; i++) {
            original[i] = [i, this.get(i) as Maybe<T>];
        }

        original
            .sort(([, a], [, b]) => this.compare(a, b))
            .forEach(([i], newPosition) => {
                if (direction === 'desc') {
                    indices[i] = Math.abs(newPosition - (len - 1));
                } else {
                    indices[i] = newPosition;
                }
            });

        return indices;
    }

    /**
     * Compare two different values on the Vector type.
     * This can be used for equality or sorted.
    */
    compare(a: Maybe<T>, b: Maybe<T>): -1|0|1 {
        const aVal = a as any;
        const bVal = b as any;
        if (aVal < bVal) return -1;
        if (aVal > bVal) return 1;
        return 0;
    }

    /**
     * Convert the Vector an array of values (the output is JSON compatible)
    */
    toJSON(): Maybe<JSONValue<T>>[] {
        const res: Maybe<JSONValue<T>>[] = Array(this.size);
        for (let i = 0; i < this.size; i++) {
            res[i] = this.get(i, true) as JSONValue<T>;
        }
        return res;
    }

    /**
     * Convert the Vector to array of values (the in-memory representation of the data)
     * @note may not be JSON spec compatible
    */
    toArray(): Maybe<T>[] {
        const res: Maybe<T>[] = Array(this.size);
        for (let i = 0; i < this.size; i++) {
            res[i] = this.get(i, false) as T;
        }
        return res;
    }

    [Symbol.for('nodejs.util.inspect.custom')](): any {
        const proxy = {
            name: this.name,
            type: this.type,
            config: this.config,
            childConfig: this.childConfig,
            size: this.size,
            isPrimitive: this.data.isPrimitive,
            values: this.data.values
        };

        // Trick so that node displays the name of the constructor
        Object.defineProperty(proxy, 'constructor', {
            value: this.constructor,
            enumerable: false
        });

        return proxy;
    }
}

/**
 * Returns true if the input is a Vector
 */
export function isVector<T>(input: unknown): input is Vector<T> {
    return input instanceof Vector;
}

/**
 * A list of Vector Options
 */
export interface VectorOptions {
    /**
    * The field config
    */
    config: DataTypeFieldConfig|Readonly<DataTypeFieldConfig>;

    /**
     * The type config for any nested fields (currently only works for objects)
    */
    childConfig?: ReadonlyDataTypeFields;

    /**
     * The name of field, if specified this will just be used for metadata
    */
    name?: string;
}

export type JSONValue<T> = T extends Vector<infer U> ? U[] : T;
export type MaybeJSONValue<T> = Maybe<T>|Maybe<JSONValue<T>>;

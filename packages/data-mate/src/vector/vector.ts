import { FieldType, Maybe } from '@terascope/types';

/**
 * The Vector Type, this will change how the data is stored and read
*/
export enum VectorType {
    /**
     * Currently this operates like String
     * but I imagine will be expanding it.
     * But will need to add format options
    */
    Date = 'Date',
    String = 'String',
    Int = 'Int',
    Float = 'Float',
    BigInt = 'BigInt',
    Boolean = 'Boolean',
    /** @todo */
    Geo = 'Geo',
    /** @todo */
    Object = 'Object',
    /**
     * Arbitrary data can be stored with this
    */
    Any = 'Any',
    /**
     * The list type is used for fields marked as Arrays
     * where each item in the Vector is a child element
    */
    List = 'List',
}

/**
 * Serialize a value to a JSON compatible format (so it can be JSON stringified)
*/
export type ValueToJSONFn<T> = (value: Maybe<T>, thisArg?: Vector<T>) => any;

/**
 * A list of Vector Options
 */
export interface VectorOptions<T> {
    fieldType: FieldType;
    data: Data<T>;
    valueToJSON?: ValueToJSONFn<T>;
}

/**
 * The in-memory storage of the data and potential indices
 * This should generated by the builder
*/
export type Data<T> = Readonly<{
    readonly values: readonly Maybe<T>[];
}>

/**
 * An immutable typed Array class with a constrained API.
 *
 * @note null/undefined values are treated the same
 *
 * @todo make immutable
*/
export abstract class Vector<T = unknown> {
    readonly type: VectorType;
    readonly fieldType: FieldType;
    readonly valueToJSON?: ValueToJSONFn<T>;

    protected readonly _size: number;
    readonly data: Data<T>;

    constructor(
        /**
         * This will be set automatically by specific Vector classes
         */
        type: VectorType,
        {
            data, fieldType, valueToJSON
        }: VectorOptions<T>
    ) {
        this.type = type;
        this.fieldType = fieldType;
        this.valueToJSON = valueToJSON;

        this.data = data;
        this._size = this.data.values.length;
    }

    * [Symbol.iterator](): IterableIterator<Maybe<T>> {
        yield* this.data.values;
    }

    /**
     * Returns the number items in the Vector
    */
    get size(): number {
        return this._size;
    }

    /**
     * Gets the number distinct values in the Vector
    */
    distinct(): number {
        return new Set(this).size;
    }

    /**
     * Get value by index
    */
    get(index: number): Maybe<T> {
        return this.data[index];
    }

    /**
     * Create a copy of the Vector
    */
    abstract clone(data?: Data<T>): Vector<T>;

    /**
     * Map over the values and return new a new Vector
    */
    map(fn: (value: Maybe<T>, index: number) => Maybe<T>): Vector<T> {
        const values: Maybe<T>[] = Array(this.size);
        for (let i = 0; i < this.size; i++) {
            values[i] = fn(this.get(i), i);
        }

        // FIXME this doesn't handle coercion
        return this.clone(Object.freeze({
            values: Object.freeze(values)
        }));
    }

    /**
     * Filter the values in the Vector, returns new Vector
    */
    filter(fn: (value: Maybe<T>, index: number) => boolean): Vector<T> {
        const values: Maybe<T>[] = [];
        for (let i = 0; i < this.size; i++) {
            const val = this.get(i);
            if (fn(val, i)) {
                values.push(val);
            }
        }

        // FIXME this doesn't handle coercion
        return this.clone(Object.freeze({
            values: Object.freeze(values)
        }));
    }

    /**
     * Reduce the values in the Vector, returns the result
    */
    reduce<R>(fn: (acc: R, value: Maybe<T>, index: number) => R, initial: R): R {
        let acc = initial;
        for (let i = 0; i < this.size; i++) {
            acc = fn(acc, this.get(i), i);
        }
        return acc;
    }

    /**
     * Slice get select values from vector
    */
    slice(start?: number, end?: number): Vector<T> {
        // FIXME this doesn't handle coercion
        return this.clone(Object.freeze({
            values: Object.freeze(this.data.values.slice(start, end))
        }));
    }

    /**
     * Convert the Vector an array of values (the output is JSON compatible)
    */
    toJSON<V = T>(): Maybe<V>[] {
        if (!this.valueToJSON) {
            return [...this] as any[];
        }

        const res: Maybe<V>[] = [];
        for (const value of this) {
            res.push(this.valueToJSON(value, this));
        }
        return res;
    }
}

/**
 * Returns true if the input is a Vector
 */
export function isVector<T>(input: unknown): input is Vector<T> {
    return input instanceof Vector;
}

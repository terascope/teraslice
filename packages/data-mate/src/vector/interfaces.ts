import { ReadableData } from '../core';

export type DataBuckets<T> = ReadableData<T>[]|readonly ReadableData<T>[];

/**
 * The Vector Type, this will change how the data is stored and read
*/
export enum VectorType {
    /**
     * Currently this operates like String
     * but I imagine will be expanding it.
     * But will need to add format options
    */
    Date = 'Date',
    String = 'String',
    Int = 'Int',
    Float = 'Float',
    BigInt = 'BigInt',
    Boolean = 'Boolean',
    GeoBoundary = 'GeoBoundary',
    GeoPoint = 'GeoPoint',
    GeoJSON = 'GeoJSON',
    IP = 'IP',
    IPRange = 'IPRange',
    Object = 'Object',
    Tuple = 'Tuple',
    /**
     * Arbitrary data can be stored with this. Not recommended for use.
    */
    Any = 'Any',
    /**
     * The list type is used for fields marked as Arrays
     * where each item in the Vector is a child element
    */
    List = 'List',
}

/**
 * A data type agnostic in-memory representation of the data
 * for a Vector and potential indices/unique values.
 *
 * This should be generated by the builder and
 * should NOT be mutated one created.
 *
 * @internal
*/
export type OldData<T> = Readonly<{
    /**
     * The index represent the order of the values,
     * the value is the hash of where to find the index
     *
     * @internal
    */
    readonly indices: readonly (string|null)[];

    /**
     * The unique values
     *
     * @internal
    */
    readonly values: ReadonlyMap<string|null, DataValueTuple<T>>;
}>;

export type DataValueTuple<T> = readonly [
    indices: readonly number[], value: T|null
];

/**
 * Options used for JSON serialization
*/
export interface SerializeOptions {
    /**
     * Use a null values in-place of undefined so
     * it can preserved when calling JSON.stringify
    */
    useNullForUndefined?: boolean;

    /**
     * Don't return any values that are null/undefined.
     * This does not apply to list or tuples, use skipNilListValues or skipNilObjectValues
     * instead.
    */
    skipNilValues?: boolean;

    /**
     * Don't return any empty List or Tuple values
    */
    skipEmptyArrays?: boolean;

    /**
     * Don't return any values that are null/undefined
    */
    skipNilListValues?: boolean;

    /**
     * Don't return any object values in list that are null/undefined.
     * This will have no change in behavior if skipNilListValues is true
    */
    skipNilObjectValues?: boolean;

    /**
     * Remove objects with properties
    */
    skipEmptyObjects?: boolean;

    /**
     * Remove duplicate objects in a list vector
    */
    skipDuplicateObjects?: boolean;
}

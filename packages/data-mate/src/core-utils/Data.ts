import { Maybe } from '@terascope/types';

/**
 * A data type agnostic in-memory representation of the data
 * for a Vector and indices/unique values.
 *
 * This should be generated by the Builder and
 * should NOT be mutated once created.
 *
 * @internal
*/
export class Data<T> {
    /**
     * The index represent the order of the values,
     * the value is the hash of where to find the index
    */
    readonly indices: TypedArray;

    /**
     * The unique values
    */
    readonly values: T[];

    nulls = 0;

    isPrimitive = false;

    #__writable = true;

    constructor(size: number) {
        this.values = [];
        this.indices = getTypedPointerArray(size);
    }

    set(index: number, value: Maybe<T>): void {
        if (!this.#__writable) {
            throw new Error('Cannot write to frozen Data instance');
        }

        if (value == null) {
            this.indices[index] = 0;
            this.nulls++;
            return;
        }
        const existingIndex = this.values.indexOf(value);
        if (existingIndex === -1) {
            const newLength = this.values.push(value);
            this.indices[index] = newLength;
        } else {
            this.indices[index] = existingIndex + 1;
        }
    }

    get(index: number): Maybe<T> {
        const valueIndex = this.indices[index];
        if (valueIndex === undefined) return undefined;
        if (valueIndex === 0) return null;

        const value = this.values[valueIndex - 1];
        if (value == null) {
            throw Error(`Value in Data not found for index ${index}`);
        }
        return value;
    }

    distinct(): number {
        if (!this.nulls) return this.values.length;
        return this.values.length + 1;
    }

    freeze(): void {
        this.#__writable = false;
        Object.freeze(this);
    }
}

export type TypedArray = Uint8Array
|Uint16Array
|Uint32Array
|Float64Array;

export type TypedArrayConstructor = Uint8ArrayConstructor
|Uint16ArrayConstructor
|Uint32ArrayConstructor
|Float64ArrayConstructor;

const MAX_8BIT_INT = (2 ** 8) - 1;
const MAX_16BIT_INT = (2 ** 16) - 1;
const MAX_32BIT_INT = (2 ** 32) - 1;

/**
 * Gets the correctly sized TypeArray depending on the length of items
 */
export function getTypedPointerArray(size: number): TypedArray {
    const maxIndex = size - 1;

    if (maxIndex <= MAX_8BIT_INT) return new Uint8Array(size);

    if (maxIndex <= MAX_16BIT_INT) return new Uint16Array(size);

    if (maxIndex <= MAX_32BIT_INT) return new Uint32Array(size);

    return new Float64Array(size);
}

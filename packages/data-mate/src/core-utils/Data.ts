import { Maybe } from '@terascope/types';
import { toString } from '@terascope/utils';

/**
 * A data type agnostic in-memory representation of the data
 * for a Vector and indices/unique values.
 *
 * This should be generated by the Builder and
 * should NOT be mutated once created.
 *
 * @internal
*/
export class Data<T> {
    /**
     * The index represent the order of the values,
     * the value is the hash of where to find the index
    */
    readonly indices: TypedArray;

    /**
     * The unique values
    */
    readonly values: T[];

    nulls = 0;

    isPrimitive = false;

    isFrozen = false;

    constructor(size?: number) {
        this.values = [];
        this.indices = size != null
            ? getTypedPointerArray(size)
            : new Float64Array();
    }

    * [Symbol.iterator](): IterableIterator<Maybe<T>> {
        for (const valIndex of this.indices) {
            if (valIndex === 0) yield null;
            else yield this.values[valIndex - 1];
        }
    }

    * associations(): IterableIterator<[readonly number[], Maybe<T>]> {
        const [reversed, nulls] = this.reverseIndices();
        const len = reversed.length;
        for (let i = 0; i < len; i++) {
            yield [reversed[i], this.values[i]];
        }
        yield [nulls, null];
    }

    set(index: number, value: Maybe<T>): Data<T> {
        this.mset([index], value);
        return this;
    }

    mset(indices: number[]|readonly number[], value: Maybe<T>): Data<T> {
        if (this.isFrozen) {
            throw new Error('Cannot write to frozen Data instance');
        }

        if (value == null) {
            for (const index of indices) {
                this.indices[index] = 0;
            }
            this.nulls += indices.length;
            return this;
        }

        const existingIndex = this.values.indexOf(value);
        let valIndex: number;
        if (existingIndex === -1) {
            valIndex = this.values.push(value);
        } else {
            valIndex = existingIndex + 1;
        }
        for (const index of indices) {
            this.indices[index] = valIndex;
        }
        return this;
    }

    get(index: number): Maybe<T> {
        const valueIndex = this.indices[index];
        if (valueIndex === undefined) return undefined;
        if (valueIndex === 0) return null;

        const value = this.values[valueIndex - 1];
        if (value == null) {
            throw Error(`Value in Data not found for index ${index}`);
        }
        return value;
    }

    distinct(): number {
        if (this.isPrimitive) {
            return this.values.length;
        }
        return new Set(this.values.map(toString)).size;
    }

    freeze(): Data<T> {
        this.isFrozen = true;
        Object.freeze(this);
        return this;
    }

    fork(length: number): Data<T> {
        if (length < this.indices.length) {
            throw new Error('Data.fork doesn\'t support decreasing the number of values');
        }
        const descriptors = Object.getOwnPropertyDescriptors(this);
        descriptors.values.value = descriptors.values.value!.slice();
        descriptors.indices.value = descriptors.indices.value!.slice();
        return Object.create(
            Object.getPrototypeOf(this),
            descriptors
        );
    }

    reverseIndices(): [reversed: (number[])[], nulls: number[]] {
        const len = this.indices.length;
        const reversed: (number[])[] = Array(this.values.length);
        const nulls = Array(this.nulls);
        let n = 0;
        for (let i = 0; i < len; i++) {
            const valIndex = this.indices[i];
            if (valIndex !== 0) {
                reversed[valIndex - 1] ??= [];
                reversed[valIndex - 1].push(i);
            } else {
                nulls[n++] = i;
            }
        }
        return [reversed, nulls];
    }
}

export type TypedArray = Uint8Array
|Uint16Array
|Uint32Array
|Float64Array;

export type TypedArrayConstructor = Uint8ArrayConstructor
|Uint16ArrayConstructor
|Uint32ArrayConstructor
|Float64ArrayConstructor;

const MAX_8BIT_INT = (2 ** 8) - 1;
const MAX_16BIT_INT = (2 ** 16) - 1;
const MAX_32BIT_INT = (2 ** 32) - 1;

/**
 * Gets the correctly sized TypeArray depending on the length of items
 */
export function getTypedPointerArray(size: number): TypedArray {
    const maxIndex = size - 1;

    if (maxIndex <= MAX_8BIT_INT) return new Uint8Array(size);

    if (maxIndex <= MAX_16BIT_INT) return new Uint16Array(size);

    if (maxIndex <= MAX_32BIT_INT) return new Uint32Array(size);

    return new Float64Array(size);
}
